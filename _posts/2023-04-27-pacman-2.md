---
layout: post
title:  Pacman - An Algorithm's Adventure in the Realm of Software Architecture
categories: [C++]
---

Let's continue our journey towards creating a general library from several algorithms, 
but today, let's take a step back from Hacker Rank (since it doesn't support C++20 yet) 
and see what we can do to improve our code using the [Concept](https://en.cppreference.com/w/cpp/concepts) feature

Let's continue our scenario where I'm a software engineer who has already developed a library of searching algorithms.
Suppose we will go through a sprint or two without any new feature requests,
and we have now taken on the task of refactoring and improving the quality of our code.
To prevent bugs that might arise from improper usage of the library, we'll be using "concepts,"
a feature introduced in the C++20 standard

Let see `pacman_bfs_dfs_example1.cpp`.

In namespace `example_1`, the user has been using `std::pair<int,int>` as the type for their search algorithm, and it seems to be working flawlessly so far.
```c++
using example_state_t = std::pair<int,int>;
using example_node_t = a_star_search::Node<example_state_t>::node_ptr_type;
                                                                                                              
void example_solve ( example_state_t const& start, example_state_t const& goal ) {                            
    auto example_get_neighbors =                                                                              
        []( example_state_t const& s ) -> std::vector<example_state_t> {return {
            {s.first-1, s.second},
            {s.first, s.second-1},
            {s.first+1, s.second},
            {s.first, s.second+1},
            {s.first+1, s.second+1},
            {s.first-1, s.second-1}
            };}; 
                                                                                                              
    std::vector<example_state_t> result_path, explored_nodes;                                                 
    auto is_solved = a_star_search::bfs_search<example_state_t, decltype(example_get_neighbors)>              
        (start, goal, std::move(example_get_neighbors), std::back_inserter(result_path), std::back_inserter(explored_nodes) ); 
                                                                                                              
    std::cout << std::boolalpha << "Task is solved: " << is_solved << "(" << result_path.size() << ")" << std::endl;
    for (const auto& p : result_path )                                                                        
        std::cout << '[' << p.first << ',' << p.second << ']'  << " ";                                                                               

    std::cout << std::endl << "Nodes visited " << explored_nodes.size() << std::endl;
}

```

Output:
```
Task is solved: true(5)
[5,5] [4,4] [3,3] [2,2] [1,1] 
Nodes visited 60
```

However, if some pointer is used as type for state like in namespace `example_2`
```c++
using example_state_t = std::shared_ptr<std::pair<int,int>>;
using example_node_t = a_star_search::Node<example_state_t>::node_ptr_type;
                                                                                                              
void example_solve ( example_state_t const& start, example_state_t const& goal ) {                            
    auto example_get_neighbors =                                                                              
        []( example_state_t const& s ) -> std::vector<example_state_t> {return {
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first-1, s->second) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first, s->second-1) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first+1, s->second) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first, s->second+1) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first+1, s->second+1) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first-1, s->second-1) )
             };
            }; 
                                                                                                              
    std::vector<example_state_t> result_path, explored_nodes;                                                 
    auto is_solved = a_star_search::bfs_search<example_state_t, decltype(example_get_neighbors)>              
        (start, goal, std::move(example_get_neighbors), std::back_inserter(result_path), std::back_inserter(explored_nodes) ); 
                                                                                                              
    std::cout << std::boolalpha << "Task is solved: " << is_solved << "(" << result_path.size() << ")" << std::endl;
    for (const auto& p : result_path )                                                                        
        std::cout << '[' << p->first << ',' << p->second << ']'  << " ";                                                                               

    std::cout << std::endl << "Nodes visited " << explored_nodes.size() << std::endl;
}
```

The program will never finish due to an obvious reason - `example_get_neighbors` cannot create the same shared pointer that was set as goal.

So, we decided to create a concept that describes the intentions of the algorithm. 
Since the standard library doesn't have one, we created a `type_trait` called `NotSmartPointer` and used it in a `concept StateSpaceEl`

```c++
namespace a_star_helper {
    template <typename T> struct is_shared_ptr : std::false_type {};
    template <typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};
    template <typename T> concept NotSharedPtr = !is_shared_ptr<T>::value;

    template <typename T> struct is_weak_ptr : std::false_type {};
    template <typename T> struct is_weak_ptr<std::weak_ptr<T>> : std::true_type {};
    template <typename T> concept NotWeakPtr = !is_weak_ptr<T>::value;

    template <typename T> struct is_unique_ptr : std::false_type {};
    template <typename T> struct is_unique_ptr<std::unique_ptr<T>> : std::true_type {};
    template <typename T> concept NotUniquePtr = !is_unique_ptr<T>::value;

    template <typename T> concept NotSmartPointer = NotSharedPtr<T> && NotWeakPtr<T> &&  NotUniquePtr<T>;
}
```

```c++
template<typename T>
concept StateSpaceEl = std::totally_ordered<T> && NotSmartPointer<T> && !std::is_pointer_v<T>;
```

As a result, any attempt to use a pointer type as the state for the algorithm is prevented with an elegant compilation error.
```c++
<source>:208:59: error: template constraint failure for 'template<class TState>  requires  StateSpaceEl<TState> class a_star_search::Node'
  208 | using example_node_t = a_star_search::Node<example_state_t>::node_ptr_type;
      |                                                           ^
<source>:208:59: note: constraints not satisfied
<source>: In substitution of 'template<class TState>  requires  StateSpaceEl<TState> class a_star_search::Node [with TState = std::shared_ptr<std::pair<int, int> >]':
<source>:208:59:   required from here
<source>:14:35:   required for the satisfaction of 'NotSharedPtr<T>' [with T = std::shared_ptr<std::pair<int, int> >]
<source>:24:35:   required for the satisfaction of 'NotSmartPointer<T>' [with T = std::shared_ptr<std::pair<int, int> >]
<source>:32:9:   required for the satisfaction of 'StateSpaceEl<TState>' [with TState = std::shared_ptr<std::pair<int, int> >]
<source>:14:50: note: the expression '!(a_star_helper::is_shared_ptr<T>::value) [with T = std::shared_ptr<std::pair<int, int> >]' evaluated to 'false'
   14 |     template <typename T> concept NotSharedPtr = !is_shared_ptr<T>::value;
      |                                                  ^~~~~~~~~~~~~~~~~~~~~~~~
```
