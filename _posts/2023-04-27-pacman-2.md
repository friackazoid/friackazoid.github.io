---
layout: post
title:  Pacman - An Algorithm's Adventure in the Realm of Software Architecture
categories: [C++]
---

Let's continue our journey towards creating a general library from several algorithms, 
but today, let's take a step back from Hacker Rank (since it doesn't support C++20 yet) 
and see what we can do to improve our code using the [Concept](https://en.cppreference.com/w/cpp/concepts) feature

Let's continue our scenario where I'm a software engineer who has already developed a library of searching algorithms.
Suppose we will go through a sprint or two without any new feature requests,
and we have now taken on the task of refactoring and improving the quality of our code.
To prevent bugs that might arise from improper usage of the library, we'll be using "concepts,"
a feature introduced in the C++20 standard

Let see `pacman_bfs_dfs_example1.cpp`.

In `namespace_1` user uses `std::pair<int,int>` as type for search algorithm and everything works just fine.
```c++
using example_state_t = std::pair<int,int>;
using example_node_t = a_star_search::Node<example_state_t>::node_ptr_type;
                                                                                                              
void example_solve ( example_state_t const& start, example_state_t const& goal ) {                            
    auto example_get_neighbors =                                                                              
        []( example_state_t const& s ) -> std::vector<example_state_t> {return {
            {s.first-1, s.second},
            {s.first, s.second-1},
            {s.first+1, s.second},
            {s.first, s.second+1},
            {s.first+1, s.second+1},
            {s.first-1, s.second-1}
            };}; 
                                                                                                              
    std::vector<example_state_t> result_path, explored_nodes;                                                 
    auto is_solved = a_star_search::bfs_search<example_state_t, decltype(example_get_neighbors)>              
        (start, goal, std::move(example_get_neighbors), std::back_inserter(result_path), std::back_inserter(explored_nodes) ); 
                                                                                                              
    std::cout << std::boolalpha << "Task is solved: " << is_solved << "(" << result_path.size() << ")" << std::endl;
    for (const auto& p : result_path )                                                                        
        std::cout << '[' << p.first << ',' << p.second << ']'  << " ";                                                                               

    std::cout << std::endl << "Nodes visited " << explored_nodes.size() << std::endl;
}

```

Output:
```
Task is solved: true(5)
[5,5] [4,4] [3,3] [2,2] [1,1] 
Nodes visited 60
```
