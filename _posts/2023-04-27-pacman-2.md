---
layout: post
title:  Pacman - An Algorithm's Adventure in the Realm of Software Architecture
categories: [C++]
---

Let's continue our journey towards creating a general library from several algorithms, 
but today, let's take a step back from Hacker Rank (since it doesn't support C++20 yet) 
and see what we can do to improve our code using the [Concept](https://en.cppreference.com/w/cpp/concepts) feature

Let's continue our scenario where I'm a software engineer who has already developed a library of searching algorithms.
Suppose we will go through a sprint or two without any new feature requests,
and we have now taken on the task of refactoring and improving the quality of our code.
To prevent bugs that might arise from improper usage of the library, we'll be using "concepts,"
a feature introduced in the C++20 standard


## Express semantic requirements
Let see `pacman_bfs_dfs_example1.cpp`.

In namespace `example_1`, the user has been using `std::pair<int,int>` as the type for their search algorithm, and it seems to be working flawlessly so far.
```c++
using example_state_t = std::pair<int,int>;
using example_node_t = a_star_search::Node<example_state_t>::node_ptr_type;
                                                                                                              
void example_solve ( example_state_t const& start, example_state_t const& goal ) {                            
    auto example_get_neighbors =                                                                              
        []( example_state_t const& s ) -> std::vector<example_state_t> {return {
            {s.first-1, s.second},
            {s.first, s.second-1},
            {s.first+1, s.second},
            {s.first, s.second+1},
            {s.first+1, s.second+1},
            {s.first-1, s.second-1}
            };}; 
                                                                                                              
    std::vector<example_state_t> result_path, explored_nodes;                                                 
    auto is_solved = a_star_search::bfs_search<example_state_t, decltype(example_get_neighbors)>              
        (start, goal, std::move(example_get_neighbors), std::back_inserter(result_path), std::back_inserter(explored_nodes) ); 
                                                                                                              
    std::cout << std::boolalpha << "Task is solved: " << is_solved << "(" << result_path.size() << ")" << std::endl;
    for (const auto& p : result_path )                                                                        
        std::cout << '[' << p.first << ',' << p.second << ']'  << " ";                                                                               

    std::cout << std::endl << "Nodes visited " << explored_nodes.size() << std::endl;
}

```

Output:
```
Task is solved: true(5)
[5,5] [4,4] [3,3] [2,2] [1,1] 
Nodes visited 60
```

However, if some pointer is used as type for state like in namespace `example_2`
```c++
using example_state_t = std::shared_ptr<std::pair<int,int>>;
using example_node_t = a_star_search::Node<example_state_t>::node_ptr_type;
                                                                                                              
void example_solve ( example_state_t const& start, example_state_t const& goal ) {                            
    auto example_get_neighbors =                                                                              
        []( example_state_t const& s ) -> std::vector<example_state_t> {return {
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first-1, s->second) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first, s->second-1) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first+1, s->second) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first, s->second+1) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first+1, s->second+1) ),
            std::make_shared<std::pair<int,int>>( std::make_pair(s->first-1, s->second-1) )
             };
            }; 
                                                                                                              
    std::vector<example_state_t> result_path, explored_nodes;                                                 
    auto is_solved = a_star_search::bfs_search<example_state_t, decltype(example_get_neighbors)>              
        (start, goal, std::move(example_get_neighbors), std::back_inserter(result_path), std::back_inserter(explored_nodes) ); 
                                                                                                              
    std::cout << std::boolalpha << "Task is solved: " << is_solved << "(" << result_path.size() << ")" << std::endl;
    for (const auto& p : result_path )                                                                        
        std::cout << '[' << p->first << ',' << p->second << ']'  << " ";                                                                               

    std::cout << std::endl << "Nodes visited " << explored_nodes.size() << std::endl;
}
```

The program will never finish due to an obvious reason - `example_get_neighbors` cannot create the same shared pointer that was set as goal.

So, we decided to create a concept that describes the intentions of the algorithm. 
Since the standard library doesn't have one, we created a `type_trait` called `NotSmartPointer` and used it in a `concept StateSpaceEl`

```c++
namespace a_star_helper {
    template <typename T> struct is_shared_ptr : std::false_type {};
    template <typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};
    template <typename T> concept NotSharedPtr = !is_shared_ptr<T>::value;

    template <typename T> struct is_weak_ptr : std::false_type {};
    template <typename T> struct is_weak_ptr<std::weak_ptr<T>> : std::true_type {};
    template <typename T> concept NotWeakPtr = !is_weak_ptr<T>::value;

    template <typename T> struct is_unique_ptr : std::false_type {};
    template <typename T> struct is_unique_ptr<std::unique_ptr<T>> : std::true_type {};
    template <typename T> concept NotUniquePtr = !is_unique_ptr<T>::value;

    template <typename T> concept NotSmartPointer = NotSharedPtr<T> && NotWeakPtr<T> &&  NotUniquePtr<T>;
}
```

```c++
template<typename T>
concept StateSpaceEl = std::totally_ordered<T> && NotSmartPointer<T> && !std::is_pointer_v<T>;
```

As a result, any attempt to use a pointer type as the state for the algorithm is prevented with an elegant compilation error.
```c++
<source>:208:59: error: template constraint failure for 'template<class TState>  requires  StateSpaceEl<TState> class a_star_search::Node'
  208 | using example_node_t = a_star_search::Node<example_state_t>::node_ptr_type;
      |                                                           ^
<source>:208:59: note: constraints not satisfied
<source>: In substitution of 'template<class TState>  requires  StateSpaceEl<TState> class a_star_search::Node [with TState = std::shared_ptr<std::pair<int, int> >]':
<source>:208:59:   required from here
<source>:14:35:   required for the satisfaction of 'NotSharedPtr<T>' [with T = std::shared_ptr<std::pair<int, int> >]
<source>:24:35:   required for the satisfaction of 'NotSmartPointer<T>' [with T = std::shared_ptr<std::pair<int, int> >]
<source>:32:9:   required for the satisfaction of 'StateSpaceEl<TState>' [with TState = std::shared_ptr<std::pair<int, int> >]
<source>:14:50: note: the expression '!(a_star_helper::is_shared_ptr<T>::value) [with T = std::shared_ptr<std::pair<int, int> >]' evaluated to 'false'
   14 |     template <typename T> concept NotSharedPtr = !is_shared_ptr<T>::value;
      |                                                  ^~~~~~~~~~~~~~~~~~~~~~~~
```

## Improve compiler error messages

Another great feature of concepts is their ability to generate improved error messages.
For example, the code from `namespace example_3` in example2 results in a confusing and unclear error message.
```c++
namespace example_3 { 
using example_state_t = std::pair<int,int>;
using example_node_t = a_star_search::Node<example_state_t>::node_ptr_type;
                                                                                                              
void example_solve ( example_state_t const& start, example_state_t const& goal ) {                            
    auto example_get_neighbors =                                                                              
        []( int const& s ) -> std::vector<int> {return {1,2,3};}; 
                                                                                                              
    std::vector<example_state_t> result_path, explored_nodes;                                                 
    auto is_solved = a_star_search::bfs_search<example_state_t, decltype(example_get_neighbors)>              
        (start, goal, std::move(example_get_neighbors), std::back_inserter(result_path), std::back_inserter(explored_nodes) ); 
                                                                                                              
    std::cout << std::boolalpha << "Task is solved: " << is_solved << "(" << result_path.size() << ")" << std::endl;
    for (const auto& p : result_path )                                                                        
        std::cout << '[' << p.first << ',' << p.second << ']'  << " ";                                                                               

    std::cout << std::endl << "Nodes visited " << explored_nodes.size() << std::endl;
}
                         
} //namespace example_3 
```

```c++
<source>: In instantiation of 'void a_star_search::NodeVisitor<TState, TContainer, FGetNeighbors>::visit_neighbors(const std::shared_ptr<a_star_search::Node<TState> >&) [with TState = std::pair<int, int>; TContainer = std::queue<std::shared_ptr<a_star_search::Node<std::pair<int, int> > >, std::deque<std::shared_ptr<a_star_search::Node<std::pair<int, int> > >, std::allocator<std::shared_ptr<a_star_search::Node<std::pair<int, int> > > > > >; FGetNeighbors = example_3::example_solve(const example_state_t&, const example_state_t&)::<lambda(const int&)>]':
<source>:132:37:   required from 'bool a_star_search::a_star(const TState&, const TState&, TNodeVisitor&, TResultPathIterator, TExploredNodeIterator) [with TState = std::pair<int, int>; TNodeVisitor = NodeVisitor<std::pair<int, int>, std::queue<std::shared_ptr<Node<std::pair<int, int> > >, std::deque<std::shared_ptr<Node<std::pair<int, int> > >, std::allocator<std::shared_ptr<Node<std::pair<int, int> > > > > >, example_3::example_solve(const example_state_t&, const example_state_t&)::<lambda(const int&)> >; TResultPathIterator = std::back_insert_iterator<std::vector<std::pair<int, int> > >; TExploredNodeIterator = std::back_insert_iterator<std::vector<std::pair<int, int> > >]'
<source>:152:19:   required from 'bool a_star_search::a_star_solve(const TState&, const TState&, const FGetNeighbors&, TResultPathIterator, TExploredNodeIterator) [with TContainer = std::queue<std::shared_ptr<Node<std::pair<int, int> > >, std::deque<std::shared_ptr<Node<std::pair<int, int> > >, std::allocator<std::shared_ptr<Node<std::pair<int, int> > > > > >; TState = std::pair<int, int>; FGetNeighbors = example_3::example_solve(const example_state_t&, const example_state_t&)::<lambda(const int&)>; TResultPathIterator = std::back_insert_iterator<std::vector<std::pair<int, int> > >; TExploredNodeIterator = std::back_insert_iterator<std::vector<std::pair<int, int> > >]'
<source>:170:9:   required from 'bool a_star_search::bfs_search(const TState&, const TState&, const FGetNeighbors&, TResultPathIterator, TExploredNodeIterator) [with TState = std::pair<int, int>; FGetNeighbors = example_3::example_solve(const example_state_t&, const example_state_t&)::<lambda(const int&)>; TResultPathIterator = std::back_insert_iterator<std::vector<std::pair<int, int> > >; TExploredNodeIterator = std::back_insert_iterator<std::vector<std::pair<int, int> > >]'
<source>:247:9:   required from here
<source>:88:55: error: no match for call to '(example_3::example_solve(const example_state_t&, const example_state_t&)::<lambda(const int&)>) (std::pair<int, int>&)'
   88 |         std::vector<TState> neighbors = get_neighbors_( current_node->state_ );
      |                                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
      ...
<source>:88:55: note: candidate: 'std::vector<int> (*)(const int&)' (conversion)
<source>:88:55: note:   candidate expects 2 arguments, 2 provided
<source>:243:9: note: candidate: 'example_3::example_solve(const example_state_t&, const example_state_t&)::<lambda(const int&)>'
  243 |         []( int const& s ) -> std::vector<int> {return {1,2,3};};
      |         ^
<source>:243:9: note:   no known conversion for argument 1 from 'std::pair<int, int>' to 'const int&'
```

By defining the GetNeighborsFunction concept for the get_neighbour_function, we can greatly improve the error messages generated by the compiler.
```c++
template <typename F, typename TState>
concept GetNeighborsFunction = std::regular_invocable<F, TState> && 
                               requires (F&& f, TState&& state) { {f(state)} -> std::same_as< std::vector<TState> >;  };
```

```c++
<source>: In function 'void example_3::example_solve(const example_state_t&, const example_state_t&)':
<source>:251:9: error: no matching function for call to 'bfs_search<example_3::example_state_t, example_3::example_solve(const example_state_t&, const example_state_t&)::<lambda(const int&)> >(const example_3::example_state_t&, const example_3::example_state_t&, std::remove_reference<example_3::example_solve(const example_state_t&, const example_state_t&)::<lambda(const int&)>&>::type, std::back_insert_iterator<std::vector<std::pair<int, int> > >, std::back_insert_iterator<std::vector<std::pair<int, int> > >)'
  250 |     auto is_solved = a_star_search::bfs_search<example_state_t, decltype(example_get_neighbors)>
      |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  251 |         (start, goal, std::move(example_get_neighbors), std::back_inserter(result_path), std::back_inserter(explored_nodes) );
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<source>:172:6: note: candidate: 'template<class TState, class FGetNeighbors, class TResultPathIterator, class TExploredNodeIterator>  requires  GetNeighborsFunction<FGetNeighbors, TState> bool a_star_search::bfs_search(const TState&, const TState&, const FGetNeighbors&, TResultPathIterator, TExploredNodeIterator)'
  172 | bool bfs_search ( TState const& start, TState const& goal, FGetNeighbors const& get_neighbors, TResultPathIterator result_path_it, TExploredNodeIterator explored_node_it ) {
      |      ^~~~~~~~~~
<source>:172:6: note:   template argument deduction/substitution failed:
<source>:172:6: note: constraints not satisfied
```
